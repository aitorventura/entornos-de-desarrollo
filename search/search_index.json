{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcda Entornos de Desarrollo","text":"<p>Bienvenido al m\u00f3dulo Entornos de Desarrollo. Aqu\u00ed encontrar\u00e1s todos los temas organizados y enlazados, cada uno con sus criterios de evaluaci\u00f3n, resultados de aprendizaje y contenidos pr\u00e1cticos.  </p>"},{"location":"#objetivo-general","title":"\ud83c\udfaf Objetivo general","text":"<p>Desarrollar las competencias necesarias para crear, probar y mejorar software utilizando herramientas profesionales. </p> <p>A lo largo del m\u00f3dulo aprender\u00e1s a:  </p> <ul> <li>Comprender qu\u00e9 es un programa inform\u00e1tico y c\u00f3mo se ejecuta en un sistema.  </li> <li>Utilizar entornos de desarrollo (IDE) para editar y generar ejecutables.  </li> <li>Dise\u00f1ar y aplicar pruebas que verifiquen el correcto funcionamiento del software.  </li> <li>Mejorar la calidad del c\u00f3digo mediante refactorizaci\u00f3n, control de versiones e integraci\u00f3n continua.  </li> <li>Representar programas con diagramas UML (clases, actividades, estados, casos de uso) para planificar y comunicar mejor las soluciones.  </li> </ul> <p>En conjunto, el objetivo es que seas capaz de trabajar como desarrollador siguiendo buenas pr\u00e1cticas, con una visi\u00f3n completa del ciclo de vida del software.</p>"},{"location":"#indice-de-contenidos","title":"\ud83d\udcd8 \u00cdndice de contenidos","text":"<p>\ud83d\udc68\u200d\ud83d\udcbb Tema 1: Desarrollo de Software</p> <ul> <li>Concepto de programa inform\u00e1tico </li> <li>C\u00f3digo fuente, objeto y ejecutable </li> <li>Lenguajes de programaci\u00f3n y paradigmas </li> <li>Fases del desarrollo del software </li> <li>Herramientas y procesos de compilaci\u00f3n </li> <li>Metodolog\u00edas \u00e1giles </li> </ul> \ud83d\udd12 Tema 2: Entornos Integrados de Desarrollo (Pr\u00f3ximamente) <ul> <li>Instalaci\u00f3n, uso y personalizaci\u00f3n  </li> <li>Edici\u00f3n de programas y generaci\u00f3n de ejecutables  </li> <li>Herramientas y automatizaci\u00f3n  </li> </ul> \ud83d\udd12 Tema 3: Verificaci\u00f3n y Pruebas de Programas (Pr\u00f3ximamente) <ul> <li>Planificaci\u00f3n y tipos de pruebas  </li> <li>Procedimientos y casos de prueba  </li> <li>Pruebas unitarias y autom\u00e1ticas  </li> <li>Documentaci\u00f3n de incidencias y dobles de prueba  </li> </ul> \ud83d\udd12 Tema 4: Optimizaci\u00f3n y Documentaci\u00f3n del C\u00f3digo (Pr\u00f3ximamente) <ul> <li>Refactorizaci\u00f3n y patrones comunes  </li> <li>Analizadores de c\u00f3digo  </li> <li>Control de versiones y repositorios  </li> <li>Documentaci\u00f3n e integraci\u00f3n continua  </li> </ul> \ud83d\udd12 Tema 5: Diagramas de Clases (Pr\u00f3ximamente) <ul> <li>Clases, atributos y m\u00e9todos  </li> <li>Relaciones (herencia, agregaci\u00f3n, composici\u00f3n, dependencia)  </li> <li>Herramientas UML  </li> <li>Generaci\u00f3n de c\u00f3digo e ingenier\u00eda inversa  </li> </ul> \ud83d\udd12 Tema 6: Diagramas de Comportamiento (Pr\u00f3ximamente) <ul> <li>Diagramas de secuencia y comunicaci\u00f3n  </li> <li>Diagramas de actividades  </li> <li>Diagramas de estados  </li> </ul> <p>C\u00f3mo navegar</p> <p>Puedes acceder a cada tema desde este \u00edndice o usando las flechas de navegaci\u00f3n al final de cada p\u00e1gina.</p>"},{"location":"tema1/","title":"\ud83d\udc68\u200d\ud83d\udcbb Tema 1: Desarrollo de Software","text":"<p>RA 1: Reconoce los elementos y herramientas que intervienen en el desarrollo de un programa inform\u00e1tico, analizando sus caracter\u00edsticas y las fases en las que act\u00faan hasta llegar a su puesta en funcionamiento.</p>"},{"location":"tema1/#criterios-de-evaluacion","title":"\ud83c\udfaf Criterios de evaluaci\u00f3n","text":"<p>\u2705 Se ha reconocido la relaci\u00f3n de los programas con los componentes del sistema inform\u00e1tico: memoria, procesador, perif\u00e9ricos, entre otros. \u2705 Se han identificado las fases de desarrollo de una aplicaci\u00f3n inform\u00e1tica. \u2705 Se han diferenciado los conceptos de c\u00f3digo fuente, objeto y ejecutable. \u2705 Se han reconocido las caracter\u00edsticas de la generaci\u00f3n de c\u00f3digo intermedio para su ejecuci\u00f3n en m\u00e1quinas virtuales. \u2705 Se han clasificado los lenguajes de programaci\u00f3n, identificando sus caracter\u00edsticas. \u2705 Se ha evaluado la funcionalidad ofrecida por las herramientas utilizadas en el desarrollo de software. \u2705 Se han identificado las caracter\u00edsticas y escenarios de uso de las metodolog\u00edas \u00e1giles de desarrollo de software.  </p>"},{"location":"tema1/#indice-de-contenidos","title":"\ud83d\udcd8 \u00cdndice de contenidos","text":"<ol> <li>Concepto de programa inform\u00e1tico</li> <li>C\u00f3digo fuente, objeto y ejecutable</li> <li>Lenguajes de programaci\u00f3n y paradigmas</li> <li>Fases del desarrollo del software</li> <li>Herramientas y procesos de compilaci\u00f3n</li> <li>Metodolog\u00edas \u00e1giles</li> </ol> <p>\u00bfC\u00f3mo avanzar por el contenido?</p> <p>Utiliza el \u00edndice o las flechas de navegaci\u00f3n al final de cada p\u00e1gina para desplazarte por los distintos apartados de este tema.</p>"},{"location":"tema1/actividad_1_1/","title":"\ud83e\uddea Actividad 1.1: Del problema al programa","text":"<p>Objetivo</p> <p>Comprender c\u00f3mo un programa transforma entradas en salidas y qu\u00e9 papel juegan la CPU, la RAM y la E/S.</p>"},{"location":"tema1/actividad_1_1/#parte-a-identificar-eps-entrada-proceso-salida","title":"\ud83d\udd39 Parte A. Identificar EPS (Entrada \u2192 Proceso \u2192 Salida)","text":"Gupo presencialGrupo semipresencial <ol> <li>Ponte en pareja con un compa\u00f1ero.  </li> <li>Pensad en tres situaciones cotidianas donde haya claramente entrada, proceso y salida. Ejemplos (esos no valen):  <ul> <li>Cajero autom\u00e1tico.  </li> <li>Reproductor de m\u00fasica.  </li> <li>Calculadora del m\u00f3vil.  </li> </ul> </li> <li>Dibujad una tabla con columnas:  </li> </ol> Entrada Proceso Salida <p>\ud83d\udcf8 A\u00f1adid un esquema r\u00e1pido (a mano o con un diagrama simple) para representar el flujo.</p> <ol> <li>Piensa en tres situaciones cotidianas donde haya claramente entrada, proceso y salida. Ejemplos (esos no valen):  <ul> <li>Cajero autom\u00e1tico.  </li> <li>Reproductor de m\u00fasica.  </li> <li>Calculadora del m\u00f3vil.  </li> </ul> </li> <li>Dibuja una tabla con columnas:  </li> </ol> Entrada Proceso Salida <p>\ud83d\udcf8 A\u00f1ade un esquema r\u00e1pido (a mano o con un diagrama simple) para representar el flujo.</p>"},{"location":"tema1/actividad_1_1/#parte-b-relacionar-con-componentes","title":"\ud83d\udd39 Parte B. Relacionar con componentes","text":"<p>Para cada caso de la tabla, responde:</p> <ul> <li>\u00bfQu\u00e9 har\u00eda la CPU?  </li> <li>\u00bfQu\u00e9 datos guardar\u00edan en la RAM?  </li> <li>\u00bfQu\u00e9 papel tendr\u00eda la E/S?  </li> <li>\u00bfIntervendr\u00eda la red o el almacenamiento?</li> </ul>"},{"location":"tema1/actividad_1_1/#parte-c-mini-reto-practico","title":"\ud83d\udd39 Parte C. Mini-reto pr\u00e1ctico","text":"<p>Analiza este peque\u00f1o c\u00f3digo en Java e investiga y deduce d\u00f3nde estar\u00eda la entrada, proceso y salida:</p> Java<pre><code>import java.util.Scanner;\n\npublic class MediaNotas {\n    public static void main(String[] args) {\n        Scanner teclado = new Scanner(System.in);\n        int suma = 0;\n\n        for (int i = 1; i &lt;= 3; i++) {\n            System.out.print(\"Introduce una nota: \");\n            int n = teclado.nextInt();\n            suma += n;\n        }\n\n        double media = suma / 3.0;\n        System.out.println(\"La media es: \" + media);\n\n        teclado.close();\n    }\n}\n</code></pre> <ul> <li>\u00bfQu\u00e9 parte es entrada?  </li> <li>\u00bfQu\u00e9 hace el proceso?  </li> <li>\u00bfCu\u00e1l es la salida?  </li> </ul>"},{"location":"tema1/actividad_1_1/#entregable","title":"\u2705 Entregable","text":"<p>Un documento breve con:</p> <ul> <li>La tabla con los tres ejemplos.  </li> <li>Un diagrama sencillo de un caso.  </li> <li>Las respuestas sobre CPU, RAM, E/S, red y almacenamiento.  </li> <li>El an\u00e1lisis del programa en Java.  </li> </ul>"},{"location":"tema1/actividad_1_2/","title":"\ud83e\uddea Actividad 1.2: Compilar e interpretar programas","text":""},{"location":"tema1/actividad_1_2/#objetivo-de-la-actividad","title":"\ud83c\udfaf Objetivo de la actividad","text":"<p>Qu\u00e9 vas a aprender</p> <ul> <li>Compilar y ejecutar programas en C y Java.  </li> <li>Interpretar un script en Python.  </li> <li>Conocer y usar compiladores e int\u00e9rpretes: <code>gcc</code> (C), <code>python3</code> (Python), <code>javac/java</code> (Java).  </li> <li>Documentar el proceso con capturas de pantalla y una reflexi\u00f3n personal.  </li> </ul>"},{"location":"tema1/actividad_1_2/#entregables-esperados-antes-de-empezar","title":"\ud83d\udcf8 Entregables esperados (antes de empezar)","text":"<p>Para que no se te olvide, durante toda la actividad debes guardar estas capturas de pantalla:</p> <ol> <li>\ud83d\udce5 Instalaci\u00f3n de cada herramienta (<code>gcc</code>, <code>python3</code>, <code>java</code>).  </li> <li>\ud83d\udcc4 Archivos creados (<code>ejemploC.c</code>, <code>ejemploPython.py</code>, <code>Ejemplo.java</code>).  </li> <li>\ud83d\udda5\ufe0f C\u00f3digo fuente abierto en el editor (nano).  </li> <li>\u2699\ufe0f Compilaci\u00f3n en C y Java (comando + resultado).  </li> <li>\u25b6\ufe0f Ejecuci\u00f3n de los tres programas en terminal (C, Python, Java).  </li> <li>\ud83d\udcc2 Vista de la carpeta <code>ejemploscodigo</code> mostrando los ejecutables generados.  </li> <li>\ud83d\udcdd Documento final con tu explicaci\u00f3n y una conclusi\u00f3n personal sobre las diferencias entre compilar e interpretar.</li> </ol>"},{"location":"tema1/actividad_1_2/#herramientas-necesarias","title":"\ud83d\udee0\ufe0f Herramientas necesarias","text":"<ul> <li>M\u00e1quina virtual con Ubuntu Server instalada.  </li> <li>Compilador C (gcc/MinGW).  </li> <li>Python 3.  </li> <li>JDK (Java Development Kit).</li> </ul> <p>Recuerda</p> <p>En el Aula Virtual tienes un tutorial para crear la m\u00e1quina virtual en Ubuntu. Si ya la tienes lista, puedes continuar directamente.</p>"},{"location":"tema1/actividad_1_2/#paso-1-crear-los-programas-de-ejemplo","title":"\ud83d\udd39 Paso 1. Crear los programas de ejemplo","text":"<p>Primero, crea la carpeta de trabajo y los archivos vac\u00edos:</p> Bash<pre><code>mkdir ejemploscodigo\ncd ejemploscodigo\ntouch ejemploC.c ejemploPython.py ejemploJava.java\n</code></pre> <p>Ahora edita cada archivo con <code>nano</code> u otro editor y pega el c\u00f3digo:</p> \ud83d\udc68\u200d\ud83d\udcbb Programa en C C<pre><code>/* Programa: Suma de dos n\u00fameros */\n#include &lt;stdio.h&gt;\n\nint main() {\n    int n1, n2, suma;\n\n    printf(\"\\n Introduzca primer numero (entero): \");\n    scanf(\"%d\", &amp;n1);\n\n    printf(\"\\n Introduzca segundo numero (entero): \");\n    scanf(\"%d\", &amp;n2);\n\n    suma = n1 + n2;\n    printf(\"\\n La suma es: %d\\n\", suma);\n\n    // Pausa\n    printf(\"\\n Presione Enter para salir...\");\n    getchar(); \n    getchar(); \n\n    return 0;\n}\n</code></pre> \ud83d\udc0d Programa en Python Python<pre><code># Programa: Suma de dos n\u00fameros \nn1 = int(input(\"Ingrese primer n\u00famero: \")) \nn2 = int(input(\"Ingrese segundo n\u00famero: \")) \nsuma = n1 + n2 \nprint(\"La suma es:\", suma) \n</code></pre> \u2615 Programa en Java Java<pre><code>import java.util.Scanner;\n\npublic class Ejemplo {\n    public static void main(String[] args) {\n        int n1, n2, suma;\n        Scanner teclado = new Scanner(System.in);\n\n        System.out.print(\"Introduce primer numero entero: \"); \n        n1 = teclado.nextInt();\n\n        System.out.print(\"Introduce segundo numero entero: \"); \n        n2 = teclado.nextInt();\n\n        suma = n1 + n2;\n        System.out.println(\"La suma es: \" + suma); \n\n        teclado.close(); \n    }\n}\n</code></pre> <p>\ud83d\udcf8 Capturas aqu\u00ed: - Vista de la carpeta <code>ejemploscodigo</code> con los tres archivos. - Cada archivo abierto en nano mostrando el c\u00f3digo escrito.  </p>"},{"location":"tema1/actividad_1_2/#paso-2-instalar-compiladores-e-interpretes","title":"\ud83d\udd39 Paso 2. Instalar compiladores e int\u00e9rpretes","text":""},{"location":"tema1/actividad_1_2/#a-instalar-compilador-c-gcc","title":"a) Instalar compilador C (gcc)","text":"Bash<pre><code>sudo apt update\nsudo apt upgrade\nsudo apt install gcc\n</code></pre>"},{"location":"tema1/actividad_1_2/#b-instalar-python","title":"b) Instalar Python","text":"Bash<pre><code>python3 --version\nsudo apt install python3\n</code></pre>"},{"location":"tema1/actividad_1_2/#c-instalar-jdk-java-development-kit","title":"c) Instalar JDK (Java Development Kit)","text":"Bash<pre><code>sudo apt search openjdk\nsudo apt install openjdk-17-jdk\njava -version\n</code></pre> <p>\ud83d\udcf8 Capturas aqu\u00ed: - Pantalla de instalaci\u00f3n de cada herramienta (gcc, python3, java). - Comando <code>--version</code> mostrando que funcionan correctamente.  </p>"},{"location":"tema1/actividad_1_2/#paso-3-compilar-e-interpretar-programas","title":"\ud83d\udd39 Paso 3. Compilar e interpretar programas","text":""},{"location":"tema1/actividad_1_2/#a-programa-en-c","title":"a) Programa en C","text":"Bash<pre><code>gcc ejemploC.c -o ejemploC.exe\n./ejemploC.exe\n</code></pre> <p>\ud83d\udcf8 Capturas aqu\u00ed: - Comando de compilaci\u00f3n (<code>gcc</code>) y ejecutable generado. - Ejecuci\u00f3n del programa mostrando la suma en terminal.  </p>"},{"location":"tema1/actividad_1_2/#b-programa-en-python","title":"b) Programa en Python","text":"Bash<pre><code>python3 ejemploPython.py\n</code></pre> <p>\ud83d\udcf8 Capturas aqu\u00ed: - Ejecuci\u00f3n del script en terminal pidiendo datos y mostrando resultado.  </p>"},{"location":"tema1/actividad_1_2/#c-programa-en-java","title":"c) Programa en Java","text":"<p>\u26a0\ufe0f Recuerda: el archivo debe llamarse como la clase p\u00fablica (<code>Ejemplo</code>).  </p> Bash<pre><code>mv ejemploJava.java Ejemplo.java\njavac Ejemplo.java\nls   # aparece Ejemplo.class (bytecode)\njava Ejemplo\n</code></pre> <p>\ud83d\udcf8 Capturas aqu\u00ed: - Comando <code>javac</code> y el archivo <code>Ejemplo.class</code> generado. - Ejecuci\u00f3n del programa con <code>java Ejemplo</code> mostrando la suma.  </p>"},{"location":"tema1/actividad_1_2/#entregables-finales","title":"\u2705 Entregables finales","text":"<p>El resultado debe ser un documento \u00fanico en PDF o Word con:</p> <ol> <li>Capturas de instalaci\u00f3n de cada lenguaje (gcc, python3, java).  </li> <li>C\u00f3digo escrito en C, Python y Java.  </li> <li>Ejecuci\u00f3n en terminal de los tres programas.  </li> <li>Explicaci\u00f3n breve de los pasos seguidos.  </li> <li>Conclusi\u00f3n personal: diferencias entre compilar (C, Java) e interpretar (Python).</li> </ol>"},{"location":"tema1/codigo/","title":"C\u00f3digo fuente, objeto y ejecutable","text":""},{"location":"tema1/codigo/#2-codigo-fuente-objeto-y-ejecutable","title":"\ud83d\udcbb 2. C\u00f3digo fuente, objeto y ejecutable","text":""},{"location":"tema1/codigo/#21-del-codigo-fuente-al-binario-como-llega-un-programa-a-la-cpu","title":"2.1 Del c\u00f3digo fuente al binario: \u00bfc\u00f3mo llega un programa a la CPU?","text":"<p>Idea b\u00e1sica</p> <p>Un ordenador solo entiende ceros y unos (binario). Los lenguajes que usamos para programar (C, Java, Python\u2026) deben traducirse hasta llegar a ese formato. Seg\u00fan el lenguaje, este \u201cviaje\u201d puede ser:  </p> <ul> <li>Compilado (todo antes de ejecutar).  </li> <li>Interpretado (l\u00ednea a l\u00ednea en el momento).  </li> <li>H\u00edbrido con m\u00e1quina virtual y JIT (un punto intermedio).  </li> </ul> \u26a1 Lenguaje compilado (C, C++)\ud83d\udcdd Lenguaje interpretado (Python, JS)\u23f1\ufe0f H\u00edbrido con VM (Java, C#) <p><pre><code>flowchart LR\nSRC[\"\u270d\ufe0f C\u00f3digo fuente (.c, .cpp)\"] --&gt; COMP[\"\u2699\ufe0f Compilador\"]\nCOMP --&gt; OBJ[\"\ud83d\udcc4 C\u00f3digo objeto (.o, .obj)\"]\nOBJ --&gt; LINK[\"\ud83d\udd17 Enlazador\"]\nLINK --&gt; EXE[\"\u25b6\ufe0f Ejecutable (.exe, ELF)\"]</code></pre> - El c\u00f3digo se traduce antes de ejecutarse. - Resultado: un ejecutable independiente que la CPU entiende directamente. - Ejemplo: programas de escritorio o videojuegos en C++.</p> <p><pre><code>flowchart LR\nSRC[\"\u270d\ufe0f C\u00f3digo fuente (.py, .js)\"] --&gt; INT[\"\ud83d\udc69\u200d\ud83d\udcbb Int\u00e9rprete\"]\nINT --&gt; RUN[\"\u25b6\ufe0f Ejecuci\u00f3n directa\"]</code></pre> - El c\u00f3digo se lee l\u00ednea a l\u00ednea en tiempo real. - No se genera un ejecutable cl\u00e1sico. - Ejemplo: scripts de Python, p\u00e1ginas web con JavaScript.</p> <p><pre><code>flowchart LR\nSRC[\"\u270d\ufe0f C\u00f3digo fuente\"] --&gt; COMP[\"\u2699\ufe0f Compilador\"]\nCOMP --&gt; BYTE[\"\ud83d\udcc4 Bytecode (Java .class, C# CIL)\"]\nBYTE --&gt; VM[\"\u2699\ufe0f M\u00e1quina Virtual (JVM / CLR)\"]\nVM --&gt; JIT[\"\u23f1\ufe0f Compilaci\u00f3n JIT\"]\nJIT --&gt; RUN[\"\u25b6\ufe0f Ejecuci\u00f3n en CPU\"]</code></pre> - El compilador genera un bytecode intermedio. - Ese bytecode se ejecuta dentro de una m\u00e1quina virtual. - La VM usa JIT para traducir lo m\u00e1s usado a binario real en tiempo de ejecuci\u00f3n. - Ejemplo: aplicaciones Android (Java/Kotlin).</p>"},{"location":"tema1/codigo/#22-compilacion-ensamblado-y-enlazado-en-compilados","title":"2.2 Compilaci\u00f3n, ensamblado y enlazado (en compilados)","text":"<ul> <li>Compilaci\u00f3n \u2192 traduce el c\u00f3digo fuente a c\u00f3digo objeto (binario incompleto).  </li> <li>Ensamblado \u2192 organiza esas instrucciones en c\u00f3digo m\u00e1quina real.  </li> <li>Enlazado (link) \u2192 une todo (archivos objeto + librer\u00edas) para obtener el ejecutable final.</li> </ul> <p>Enlazado est\u00e1tico vs din\u00e1mico</p> <ul> <li> Est\u00e1tico \u2192 el ejecutable incluye todo. M\u00e1s grande, pero no necesita librer\u00edas externas.  </li> <li> Din\u00e1mico \u2192 el ejecutable depende de librer\u00edas externas (<code>.dll</code>, <code>.so</code>). M\u00e1s ligero, pero puede fallar si faltan.  </li> </ul>"},{"location":"tema1/codigo/#23-diferencia-entre-codigo-objeto-y-ejecutable","title":"2.3 Diferencia entre c\u00f3digo objeto y ejecutable","text":"\ud83d\udcc4 C\u00f3digo objeto\u25b6\ufe0f C\u00f3digo binario ejecutable <ul> <li>Archivo intermedio tras compilar.  </li> <li>Tiene instrucciones en binario, pero con marcas y s\u00edmbolos sin resolver.  </li> <li>Ejemplo: <code>programa.o</code> (Linux), <code>programa.obj</code> (Windows).  </li> <li>\u26a0\ufe0f No puede ejecutarse directamente.</li> </ul> <ul> <li>Archivo final que puedes abrir (<code>.exe</code>, ELF, Mach-O).  </li> <li>Ya tiene todas las direcciones resueltas y librer\u00edas enlazadas.  </li> <li>Ejemplo: <code>notepad.exe</code> en Windows, <code>/bin/ls</code> en Linux.  </li> <li>\u2705 La CPU lo entiende directamente.</li> </ul>"},{"location":"tema1/codigo/#24-ejecutable-y-dependencias","title":"2.4 Ejecutable y dependencias","text":"<p>Ejecutable</p> <p>Un ejecutable puede necesitar: </p> <ul> <li>Librer\u00edas (<code>libc.so</code>, <code>msvcrt.dll</code>).  </li> <li>Archivos de configuraci\u00f3n.  </li> <li>Recursos extra (im\u00e1genes, sonidos, bases de datos\u2026).  </li> </ul> <p>Error com\u00fan</p> <p>Creer que un <code>.exe</code> lo tiene todo dentro. En realidad, muchos programas fallan si falta una librer\u00eda externa.</p>"},{"location":"tema1/codigo/#25-interpretado-vs-compilado-vs-jit-resumen-general","title":"2.5 Interpretado vs compilado vs JIT (resumen general)","text":"Tipo C\u00f3mo funciona Ejemplo Pros Contras Interpretado El int\u00e9rprete lee y ejecuta el c\u00f3digo l\u00ednea a l\u00ednea, en tiempo real. Python, JavaScript + Flexible: se puede probar y modificar f\u00e1cilmente sin recompilar.  + Multiplataforma: el mismo script puede correr en Windows, Linux o macOS siempre que haya int\u00e9rprete. \u2013 M\u00e1s lento: porque cada instrucci\u00f3n se traduce al vuelo, no est\u00e1 preprocesada.  \u2013 Depende del int\u00e9rprete: sin \u00e9l, el programa no puede ejecutarse. Compilado Se traduce todo el programa de una vez a c\u00f3digo m\u00e1quina antes de ejecutarlo. C, C++ + Muy r\u00e1pido: la CPU ejecuta directamente el binario, sin pasos intermedios.  + Optimizable: el compilador puede aplicar mejoras (optimizaciones) en el binario. \u2013 Menos flexible: cualquier cambio en el c\u00f3digo obliga a recompilar.  \u2013 Menos portable: el binario generado suele funcionar solo en un sistema o arquitectura concreta. JIT (Just-in-time) El programa se compila primero a un c\u00f3digo intermedio (bytecode) y, en tiempo de ejecuci\u00f3n, la m\u00e1quina virtual traduce \u201cal vuelo\u201d las partes m\u00e1s usadas a binario. Java (JVM), C# (.NET) + Equilibrio: combina la portabilidad del bytecode con la velocidad del binario.  + Adaptable: el JIT optimiza seg\u00fan c\u00f3mo se ejecuta el programa en cada m\u00e1quina. \u2013 M\u00e1s complejo: necesita tanto un compilador como una m\u00e1quina virtual.  \u2013 Inicio m\u00e1s lento: al principio puede tardar m\u00e1s porque compila sobre la marcha."},{"location":"tema1/codigo/#26-codigo-intermedio-y-maquinas-virtuales","title":"2.6 C\u00f3digo intermedio y m\u00e1quinas virtuales","text":"<p>Idea clave</p> <p>Algunos lenguajes (Java, C#) no generan binario directo, sino un c\u00f3digo intermedio. Ese c\u00f3digo se ejecuta dentro de una m\u00e1quina virtual (VM).</p> \u2615 Java\ud83d\udd37 C# <ul> <li>El compilador genera bytecode (<code>.class</code>).  </li> <li>La JVM lo ejecuta.  </li> <li>Para acelerar, usa JIT que convierte a binario solo lo m\u00e1s repetido.</li> </ul> <ul> <li>El compilador genera CIL (Common Intermediate Language).  </li> <li>La CLR lo ejecuta.  </li> <li>Tambi\u00e9n usa JIT para mejorar rendimiento.</li> </ul> <p>AOT (Ahead-of-Time)</p> <p>Significa compilar antes de ejecutar, evitando JIT. Ejemplo: GraalVM para Java.  </p>"},{"location":"tema1/codigo/#27-empaquetado-y-distribucion","title":"2.7 Empaquetado y distribuci\u00f3n","text":"<p>Un programa no siempre llega como un \u00fanico archivo:</p> <ul> <li> Instaladores \u2192 <code>.exe</code>, <code>.msi</code> (Windows), <code>.deb</code>, <code>.rpm</code> (Linux).  </li> <li> Bundling \u2192 programa + dependencias (ej.: apps portables, Electron).  </li> <li> Contenedores \u2192 incluyen programa + librer\u00edas + mini SO (ej.: Docker).  </li> </ul> <p>Ejemplo cotidiano</p> <ul> <li>\ud83c\udfae Videojuego en PC \u2192 instalador cl\u00e1sico.  </li> <li>\ud83d\udcf1 App Android \u2192 archivo <code>.apk</code>.  </li> <li>\ud83c\udf10 Servicio web \u2192 contenedor Docker.</li> </ul>"},{"location":"tema1/concepto/","title":"Concepto de programa inform\u00e1tico","text":""},{"location":"tema1/concepto/#1-concepto-de-programa-informatico","title":"\ud83d\udc68\u200d\ud83d\udcbb 1. Concepto de programa inform\u00e1tico","text":""},{"location":"tema1/concepto/#11-definicion-y-proposito","title":"1.1 Definici\u00f3n y prop\u00f3sito","text":"<p>Definici\u00f3n breve</p> <p>Un programa inform\u00e1tico es un conjunto ordenado de instrucciones que, al ejecutarse en un ordenador a trav\u00e9s de su sistema operativo, transforma entradas (datos) en salidas (resultados) para resolver un problema concreto.</p>"},{"location":"tema1/concepto/#para-que-sirve","title":"\u00bfPara qu\u00e9 sirve?","text":"<ul> <li>Automatizar tareas repetitivas.</li> <li>Procesar y analizar datos para obtener informaci\u00f3n \u00fatil.</li> <li>Ofrecer servicios (una web, una app, una API).</li> <li>Controlar hardware (impresoras, sensores, robots\u2026).</li> <li>Ayudar a tomar decisiones (por ejemplo, calcular una media o recomendar contenidos).</li> </ul>"},{"location":"tema1/concepto/#como-lo-hace-entrada-proceso-salida","title":"C\u00f3mo lo hace (Entrada \u2192 Proceso \u2192 Salida)","text":"<ol> <li>Entrada: llegan datos (lo que escribes, un archivo, un clic, una lectura de un sensor\u2026).  </li> <li>Proceso: el programa aplica sus instrucciones (el \u201cc\u00f3mo\u201d).  </li> <li>Salida: devuelve un resultado (un n\u00famero, un mensaje, un documento, encender un LED\u2026).</li> </ol> <pre><code>flowchart LR\n  A[\"Entradas\n(datos, eventos)\nEj.: calificaciones, texto, clics, sensores\"]\n    --&gt; B[\"Programa\n(instrucciones)\nEj.: pasos que transforman las entradas\"]\n    --&gt; C[\"Salidas\n(resultados)\nEj.: numeros, mensajes, archivos,\nacciones en hardware\"]</code></pre> <p>Ejemplo: Nota media</p> <ul> <li>Entrada: notas de 5 asignaturas (6, 7, 8, 5, 9).  </li> <li>Proceso: sumar todo y dividir entre 5.  </li> <li>Salida: media = 7,0.</li> </ul>"},{"location":"tema1/concepto/#conceptos-clave","title":"Conceptos clave","text":"<p>Algoritmo vs. programa</p> <ul> <li>Algoritmo: procedimiento finito, preciso y no ambiguo que resuelve una clase de problemas.  </li> <li>Programa: implementaci\u00f3n concreta de un algoritmo en un lenguaje que un ordenador puede ejecutar.</li> </ul>"},{"location":"tema1/concepto/#ejemplo-encontrar-el-maximo-de-una-lista","title":"Ejemplo: encontrar el m\u00e1ximo de una lista","text":"Algoritmo (explicado) Programa en Java  <p>Problema. Dada una lista de n\u00fameros, queremos el mayor.</p> <p>Idea general. - Tomamos el primer valor como candidato a m\u00e1ximo. - Recorremos la lista de izquierda a derecha. - Si aparece un n\u00famero mayor que el candidato, lo sustituimos. - Al terminar, el candidato es el m\u00e1ximo.</p> <p>Detalles importantes. - La lista debe tener al menos un elemento. - Solo necesitamos una variable adicional. - Una comparaci\u00f3n por elemento \u2192 coste lineal.</p> Java<pre><code>public class MaximoLista {\n    public static int maximo(int[] a) {\n        int max = a[0];                 // candidato inicial\n        for (int i = 1; i &lt; a.length; i++) {\n            if (a[i] &gt; max) {           // \u00bfhay un n\u00famero mayor?\n                max = a[i];             // actualizamos el candidato\n            }\n        }\n        return max;                     // al final, max es el mayor\n    }\n\n    public static void main(String[] args) {\n        int[] numeros = {6, 7, 8, 5, 9};\n        int max = maximo(numeros);\n        System.out.println(\"M\u00e1ximo = \" + max); // -&gt; 9\n    }\n}\n</code></pre> <p>Errores habituales (a evitar)</p> <ul> <li> <p>\u274c Confundir datos de entrada con configuraci\u00f3n del programa.   Los datos de entrada son la informaci\u00f3n que el programa necesita para trabajar (ej.: n\u00fameros a sumar).   La configuraci\u00f3n son ajustes fijos que cambian el comportamiento del programa (ej.: idioma de la aplicaci\u00f3n).   \u2192 Si los mezclas, el programa puede dar resultados inesperados.  </p> </li> <li> <p>\u274c Pensar que un programa siempre tiene interfaz gr\u00e1fica.   Muchos programas funcionan sin ventanas: en consola, como scripts, o en segundo plano como servicios.   \u2192 Un programa no necesita \u201cpantalla bonita\u201d para ser \u00fatil.  </p> </li> <li> <p>\u274c Olvidar el papel del sistema operativo.   El programa no controla el hardware de forma directa: hace peticiones al sistema operativo.   \u2192 Si el SO no gestionara CPU, memoria o disco, los programas chocar\u00edan entre s\u00ed y el sistema se colapsar\u00eda.  </p> </li> </ul>"},{"location":"tema1/concepto/#12-tipos-de-programas-sistemas-aplicaciones-utilidades-y-servicios","title":"1.2 Tipos de programas: sistemas, aplicaciones, utilidades y servicios","text":"<p>Idea clave</p> <p>Los programas inform\u00e1ticos se pueden clasificar seg\u00fan su prop\u00f3sito. Esta clasificaci\u00f3n ayuda a entender qu\u00e9 papel cumple cada software dentro de un ordenador o en la red.</p>"},{"location":"tema1/concepto/#programas-de-sistema","title":"Programas de sistema","text":"<ul> <li>Qu\u00e9 son: software que conecta y gestiona el hardware.  </li> <li>Ejemplos: sistemas operativos (Windows, Linux, macOS), drivers, firmware.  </li> </ul> <p>Recuerda</p> <p>Sin un sistema operativo, el resto de programas no podr\u00edan ejecutarse.</p>"},{"location":"tema1/concepto/#aplicaciones","title":"Aplicaciones","text":"<ul> <li>Qu\u00e9 son: programas dise\u00f1ados para que el usuario final realice tareas concretas.  </li> <li>Ejemplos: navegador web, editor de texto, juego, app del tiempo, procesador de im\u00e1genes.  </li> </ul>"},{"location":"tema1/concepto/#utilidades","title":"Utilidades","text":"<ul> <li>Qu\u00e9 son: programas de apoyo que facilitan tareas t\u00e9cnicas o ayudan a mantener el sistema.  </li> <li>Ejemplos: antivirus, compresores (WinRAR, 7zip), limpiadores de disco, monitores de red.  </li> </ul>"},{"location":"tema1/concepto/#servicios","title":"Servicios","text":"<ul> <li>Qu\u00e9 son: programas que trabajan en segundo plano, sin necesidad de que el usuario los abra manualmente.  </li> <li>Ejemplos: servidor web (Apache, Nginx), base de datos (MySQL, MongoDB), servicio de copias autom\u00e1ticas.  </li> </ul> <p>Importante</p> <p>Un servicio no suele tener ventana ni icono. Est\u00e1 \u201cescuchando\u201d peticiones (por ejemplo desde Internet) y responde cuando hace falta.</p>"},{"location":"tema1/concepto/#resumen-en-tabla","title":"Resumen en tabla","text":"Tipo Para qu\u00e9 sirve Ejemplos  Sistema Gestiona hardware y recursos Windows, Linux, drivers  Aplicaci\u00f3n Ayuda al usuario a realizar tareas Word, Chrome, Minecraft  Utilidad Facilita el mantenimiento t\u00e9cnico Antivirus, WinRAR  Servicio Trabaja en segundo plano, atiende peticiones Servidor web, base de datos"},{"location":"tema1/concepto/#esquema-visual","title":"Esquema visual","text":""},{"location":"tema1/concepto/#13-programas-y-componentes-del-sistema-cpu-memoria-almacenamiento-es-red","title":"1.3 Programas y componentes del sistema: CPU, memoria, almacenamiento, E/S, red","text":"<p>Idea clave</p> <p>Un programa no habla directamente con el hardware. Lo hace a trav\u00e9s del sistema operativo, que act\u00faa como intermediario y reparte los recursos.</p>"},{"location":"tema1/concepto/#cpu-procesador","title":"CPU (procesador)","text":"<ul> <li>Qu\u00e9 hace: ejecuta las instrucciones del programa paso a paso.  </li> <li>Ejemplo mental: es como el cerebro del ordenador.  </li> <li>Importante: la velocidad de la CPU influye en la rapidez con que el programa responde.</li> </ul>"},{"location":"tema1/concepto/#memoria-ram","title":"Memoria RAM","text":"<ul> <li>Qu\u00e9 hace: guarda temporalmente datos e instrucciones mientras se usan.  </li> <li>Ejemplo mental: una mesa de trabajo: cuanto m\u00e1s grande, m\u00e1s cosas caben a la vez.  </li> <li>Detalle: cuando apagas el PC, la RAM se borra.</li> </ul>"},{"location":"tema1/concepto/#almacenamiento","title":"Almacenamiento","text":"<ul> <li>Qu\u00e9 hace: conserva la informaci\u00f3n de forma permanente (aunque apagues el ordenador).  </li> <li>Ejemplo mental: un archivador donde guardas documentos.  </li> <li>Tipos: discos duros (HDD), discos s\u00f3lidos (SSD).  </li> </ul>"},{"location":"tema1/concepto/#entradasalida-es","title":"Entrada/Salida (E/S)","text":"<ul> <li>Qu\u00e9 hace: permite la comunicaci\u00f3n con el exterior.  </li> <li>Ejemplos de entrada: teclado, rat\u00f3n, micr\u00f3fono, c\u00e1mara.  </li> <li>Ejemplos de salida: monitor, impresora, altavoces.  </li> </ul>"},{"location":"tema1/concepto/#red","title":"Red","text":"<ul> <li>Qu\u00e9 hace: conecta el ordenador con otros equipos para compartir informaci\u00f3n.  </li> <li>Ejemplo mental: como una carretera por la que circulan los datos.  </li> <li>Ejemplo: navegar por Internet, descargar un archivo, jugar en l\u00ednea.  </li> </ul>"},{"location":"tema1/concepto/#esquema-general","title":"Esquema general","text":"<pre><code>flowchart TB\n  Program[Programa / Proceso] --&gt;|\"Llamadas (peticiones)\"| SO[Sistema Operativo]\n  SO --&gt; CPU[CPU]\n  SO --&gt; RAM[Memoria RAM]\n  SO --&gt; DISK[Almacenamiento]\n  SO --&gt; IO[Dispositivos E/S]\n  SO --&gt; NET[Red]</code></pre> <p>Ejemplo cotidiano</p> <p>Piensa en ver un v\u00eddeo en YouTube:  </p> <ul> <li>CPU: procesa las instrucciones del reproductor.  </li> <li>RAM: guarda los datos del v\u00eddeo en reproducci\u00f3n.  </li> <li>Almacenamiento: puede guardar el v\u00eddeo descargado.  </li> <li>E/S: la pantalla muestra im\u00e1genes, los altavoces reproducen sonido.  </li> <li>Red: recibe los datos del v\u00eddeo desde Internet.  </li> </ul>"},{"location":"tema1/fases/","title":"Fases del desarrollo","text":""},{"location":"tema1/fases/#4-fases-del-desarrollo-del-software","title":"4. \ud83d\udee0 Fases del desarrollo del software","text":"<pre><code>graph TD;\n    A[An\u00e1lisis] --&gt; B[Dise\u00f1o];\n    B --&gt; C[Codificaci\u00f3n];\n    C --&gt; D[Pruebas];\n    D --&gt; E[Documentaci\u00f3n];\n    E --&gt; F[Explotaci\u00f3n];\n    F --&gt; G[Mantenimiento];</code></pre>"},{"location":"tema1/fases/#resumen-de-fases","title":"\ud83d\udccc Resumen de fases","text":"<ul> <li>An\u00e1lisis: Requisitos del cliente</li> <li>Dise\u00f1o: Arquitectura del software</li> <li>Codificaci\u00f3n: Programaci\u00f3n del sistema</li> <li>Pruebas: Validaci\u00f3n del funcionamiento</li> <li>Documentaci\u00f3n: Manuales y gu\u00edas</li> <li>Explotaci\u00f3n: Puesta en marcha</li> <li>Mantenimiento: Evoluci\u00f3n y correcci\u00f3n</li> </ul>"},{"location":"tema1/herramientas/","title":"Herramientas","text":""},{"location":"tema1/herramientas/#5-herramientas-y-procesos-de-compilacion","title":"5. \ud83d\udd27 Herramientas y procesos de compilaci\u00f3n","text":"<ul> <li>Editor de c\u00f3digo: VS Code, Sublime, etc.</li> <li>Compilador/Int\u00e9rprete: GCC, Python, Java</li> <li>Linker: Enlaza c\u00f3digo objeto</li> <li>Entornos integrados (IDE): Eclipse, NetBeans, Visual Studio</li> </ul> <p>\u00bfQu\u00e9 diferencias hay entre compilaci\u00f3n e interpretaci\u00f3n?</p> <p>La compilaci\u00f3n traduce todo el c\u00f3digo de una vez; la interpretaci\u00f3n lo ejecuta l\u00ednea a l\u00ednea.</p>"},{"location":"tema1/lenguajes/","title":"Lenguajes","text":""},{"location":"tema1/lenguajes/#3-lenguajes-de-programacion-y-paradigmas","title":"3. \ud83e\udde0 Lenguajes de programaci\u00f3n y paradigmas","text":""},{"location":"tema1/lenguajes/#tipos-de-lenguajes","title":"\ud83d\udcda Tipos de lenguajes","text":"<ul> <li>\ud83e\uddee Lenguaje m\u00e1quina</li> <li>\u2699\ufe0f Ensamblador</li> <li>\ud83d\udcbb Alto nivel (Python, Java, C++)</li> <li>\ud83c\udfa8 Visuales (Scratch, Blockly)</li> </ul>"},{"location":"tema1/lenguajes/#paradigmas-de-programacion","title":"\ud83e\udded Paradigmas de programaci\u00f3n","text":"<ul> <li>Programaci\u00f3n estructurada</li> <li>Programaci\u00f3n orientada a objetos</li> <li>Programaci\u00f3n funcional</li> <li>Programaci\u00f3n visual</li> </ul> <p>Consejo</p> <p>Cada paradigma se adapta a un tipo de problema y favorece un estilo de dise\u00f1o.</p>"},{"location":"tema2/","title":"\ud83d\udee0\ufe0f Tema 2: Entornos Integrados de Desarrollo (IDE)","text":"<p>RA 2: Eval\u00faa entornos integrados de desarrollo analizando sus caracter\u00edsticas para editar c\u00f3digo fuente y generar ejecutables.</p>"},{"location":"tema2/#criterios-de-evaluacion","title":"\ud83c\udfaf Criterios de evaluaci\u00f3n","text":"<p>\u2705 Se han instalado entornos de desarrollo, tanto propietarios como libres. \u2705 Se han a\u00f1adido y eliminado m\u00f3dulos en el entorno de desarrollo. \u2705 Se ha personalizado y automatizado el entorno de desarrollo. \u2705 Se ha configurado el sistema de actualizaci\u00f3n del entorno de desarrollo. \u2705 Se han generado ejecutables a partir de c\u00f3digo fuente de diferentes lenguajes en un mismo entorno. \u2705 Se han generado ejecutables a partir de un mismo c\u00f3digo fuente en varios entornos de desarrollo. \u2705 Se han identificado las caracter\u00edsticas comunes y espec\u00edficas de diversos entornos de desarrollo.  </p>"},{"location":"tema2/#indice-de-contenidos","title":"\ud83d\udcd8 \u00cdndice de contenidos","text":"<ol> <li>Funciones de un entorno de desarrollo </li> <li>Instalaci\u00f3n de un entorno de desarrollo </li> <li>Uso b\u00e1sico de un entorno de desarrollo </li> <li>Personalizaci\u00f3n del entorno de desarrollo </li> <li>Edici\u00f3n de programas </li> <li>Generaci\u00f3n de ejecutables en distintos entornos </li> <li>Herramientas y automatizaci\u00f3n </li> </ol>"},{"location":"tema3/","title":"\ud83e\uddea Tema 3: Verificaci\u00f3n y Pruebas de Programas","text":"<p>RA 3: Verifica el funcionamiento de programas dise\u00f1ando y realizando pruebas.</p>"},{"location":"tema3/#criterios-de-evaluacion","title":"\ud83c\udfaf Criterios de evaluaci\u00f3n","text":"<p>\u2705 Se han identificado los diferentes tipos de pruebas. \u2705 Se han definido casos de prueba. \u2705 Se han identificado las herramientas de depuraci\u00f3n y prueba de aplicaciones ofrecidas por el entorno de desarrollo. \u2705 Se han utilizado herramientas de depuraci\u00f3n para definir puntos de ruptura y seguimiento. \u2705 Se han utilizado las herramientas de depuraci\u00f3n para examinar y modificar el comportamiento de un programa en tiempo de ejecuci\u00f3n. \u2705 Se han efectuado pruebas unitarias de clases y funciones. \u2705 Se han implementado pruebas autom\u00e1ticas. \u2705 Se han documentado las incidencias detectadas. \u2705 Se han utilizado dobles de prueba para aislar los componentes durante las pruebas.  </p>"},{"location":"tema3/#indice-de-contenidos","title":"\ud83d\udcd8 \u00cdndice de contenidos","text":"<ol> <li>Planificaci\u00f3n de pruebas </li> <li>Tipos de pruebas: funcionales, estructurales y regresi\u00f3n </li> <li>Procedimientos y casos de prueba </li> <li>Pruebas de c\u00f3digo: cubrimiento, valores l\u00edmite y clases de equivalencia </li> <li>Pruebas unitarias y herramientas de automatizaci\u00f3n </li> <li>Documentaci\u00f3n de incidencias </li> <li>Dobles de prueba: tipos y caracter\u00edsticas </li> </ol>"},{"location":"tema4/","title":"\ud83e\uddea Tema 3: Verificaci\u00f3n y Pruebas de Programas","text":"<p>RA 3: Verifica el funcionamiento de programas dise\u00f1ando y realizando pruebas.</p>"},{"location":"tema4/#criterios-de-evaluacion","title":"\ud83c\udfaf Criterios de evaluaci\u00f3n","text":"<p>\u2705 Se han identificado los diferentes tipos de pruebas. \u2705 Se han definido casos de prueba. \u2705 Se han identificado las herramientas de depuraci\u00f3n y prueba de aplicaciones ofrecidas por el entorno de desarrollo. \u2705 Se han utilizado herramientas de depuraci\u00f3n para definir puntos de ruptura y seguimiento. \u2705 Se han utilizado las herramientas de depuraci\u00f3n para examinar y modificar el comportamiento de un programa en tiempo de ejecuci\u00f3n. \u2705 Se han efectuado pruebas unitarias de clases y funciones. \u2705 Se han implementado pruebas autom\u00e1ticas. \u2705 Se han documentado las incidencias detectadas. \u2705 Se han utilizado dobles de prueba para aislar los componentes durante las pruebas.  </p>"},{"location":"tema4/#indice-de-contenidos","title":"\ud83d\udcd8 \u00cdndice de contenidos","text":"<ol> <li>Planificaci\u00f3n de pruebas </li> <li>Tipos de pruebas: funcionales, estructurales y regresi\u00f3n </li> <li>Procedimientos y casos de prueba </li> <li>Pruebas de c\u00f3digo: cubrimiento, valores l\u00edmite y clases de equivalencia </li> <li>Pruebas unitarias y herramientas de automatizaci\u00f3n </li> <li>Documentaci\u00f3n de incidencias </li> <li>Dobles de prueba: tipos y caracter\u00edsticas </li> </ol>"},{"location":"tema5/","title":"\ud83c\udfd7\ufe0f Tema 5: Diagramas de Clases en el Desarrollo de Aplicaciones","text":"<p>RA 5: Genera diagramas de clases valorando su importancia en el desarrollo de aplicaciones y empleando herramientas espec\u00edficas.</p>"},{"location":"tema5/#criterios-de-evaluacion","title":"\ud83c\udfaf Criterios de evaluaci\u00f3n","text":"<p>\u2705 Se han identificado los conceptos b\u00e1sicos de la programaci\u00f3n orientada a objetos. \u2705 Se han utilizado herramientas para la elaboraci\u00f3n de diagramas de clases. \u2705 Se ha interpretado el significado de diagramas de clases. \u2705 Se han trazado diagramas de clases a partir de las especificaciones de las mismas. \u2705 Se ha generado c\u00f3digo a partir de un diagrama de clases. \u2705 Se ha generado un diagrama de clases mediante ingenier\u00eda inversa.  </p>"},{"location":"tema5/#indice-de-contenidos","title":"\ud83d\udcd8 \u00cdndice de contenidos","text":"<ol> <li>Conceptos b\u00e1sicos de la POO: clases, atributos y m\u00e9todos </li> <li>Objetos e instanciaci\u00f3n </li> <li>Relaciones en diagramas de clases </li> <li>Notaci\u00f3n de los diagramas de clases </li> <li>Herramientas para la elaboraci\u00f3n de diagramas </li> <li>Generaci\u00f3n autom\u00e1tica de c\u00f3digo </li> <li>Ingenier\u00eda inversa: de c\u00f3digo a diagrama </li> </ol>"},{"location":"tema6/","title":"\ud83d\udd04 Tema 6: Diagramas de Comportamiento en el Desarrollo de Aplicaciones","text":"<p>RA 6: Genera diagramas de comportamiento valorando su importancia en el desarrollo de aplicaciones y empleando herramientas espec\u00edficas.</p>"},{"location":"tema6/#criterios-de-evaluacion","title":"\ud83c\udfaf Criterios de evaluaci\u00f3n","text":"<p>\u2705 Se han identificado los distintos tipos de diagramas de comportamiento. \u2705 Se ha reconocido el significado de los diagramas de casos de uso. \u2705 Se han interpretado diagramas de interacci\u00f3n. \u2705 Se han elaborado diagramas de interacci\u00f3n sencillos. \u2705 Se ha interpretado el significado de diagramas de actividades. \u2705 Se han elaborado diagramas de actividades sencillos. \u2705 Se han interpretado diagramas de estados. \u2705 Se han planteado diagramas de estados sencillos.  </p>"},{"location":"tema6/#indice-de-contenidos","title":"\ud83d\udcd8 \u00cdndice de contenidos","text":"<ol> <li>Tipos de diagramas de comportamiento y campo de aplicaci\u00f3n </li> <li>Diagrama de casos de uso: actores, escenarios y comunicaci\u00f3n </li> <li>Diagramas de interacci\u00f3n </li> <li>Diagrama de secuencia </li> <li>Diagrama de comunicaci\u00f3n </li> <li>Diagrama de actividades </li> <li>Diagrama de estados </li> </ol>"}]}